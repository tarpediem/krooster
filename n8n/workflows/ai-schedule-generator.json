{
  "name": "AI Schedule Generator",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "api/ai/generate-schedule",
        "options": {},
        "responseMode": "responseNode"
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "webhookId": "ai-generate",
      "position": [240, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT e.id, e.last_name, e.first_name, e.positions, e.is_mobile, r.name AS restaurant_name, r.id AS restaurant_id, COALESCE(e.employment_type, 'full_time') AS employment_type, e.days_off, e.max_hours_per_week, r.opening_hours, r.closing_hours, r.closed_dates FROM employees e JOIN restaurants r ON e.restaurant_id = r.id WHERE e.active = TRUE ORDER BY r.id, e.last_name;",
        "options": {}
      },
      "id": "fetch-employees",
      "name": "Fetch Employees",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [480, 200],
      "credentials": {"postgres": {"id": "GvtIl9xYacgDPoso", "name": "Planning PostgreSQL"}}
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT employee_id, start_date, end_date FROM absences WHERE status = 'approved' AND end_date >= CURRENT_DATE;",
        "options": {}
      },
      "id": "fetch-leaves",
      "name": "Fetch Leaves",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [480, 400],
      "credentials": {"postgres": {"id": "GvtIl9xYacgDPoso", "name": "Planning PostgreSQL"}}
    },
    {
      "parameters": {"mode": "append"},
      "id": "merge-data",
      "name": "Merge",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [720, 300]
    },
    {
      "parameters": {
        "jsCode": "// Algorithmic Schedule Generator with restaurant-specific hours\nconst webhookData = $('Webhook Trigger').first().json;\nconst allEmployees = $('Fetch Employees').all().map(e => e.json);\nconst allLeaves = $('Fetch Leaves').all().map(l => l.json);\n\nconst startDate = new Date(webhookData.body?.start_date || new Date().toISOString().split('T')[0]);\nconst endDate = new Date(webhookData.body?.end_date || new Date(Date.now() + 7*24*60*60*1000).toISOString().split('T')[0]);\nconst createShifts = webhookData.body?.create_shifts === true;\nconst includeExtras = webhookData.body?.include_extras === true;\n\n// Restaurant-specific shifts based on operating hours\n// Hua Hin (id=1): 11:00-23:00, closed Jan 1st\n// Sathorn (id=2): 10:30-00:30\nconst RESTAURANT_SHIFTS = {\n  1: { // Hua Hin - A la mer by Kosmo\n    name: 'A la mer by Kosmo',\n    morning: { start: '11:00', end: '17:30', break_start: '14:00', hours: 6.5 },\n    afternoon: { start: '17:00', end: '23:00', break_start: '20:00', hours: 6 },\n    closedDates: [] // Will be populated from DB\n  },\n  2: { // Sathorn - Kosmo\n    name: 'Kosmo',\n    morning: { start: '10:30', end: '17:30', break_start: '14:00', hours: 7 },\n    afternoon: { start: '17:30', end: '00:30', break_start: '21:00', hours: 7 },\n    closedDates: []\n  }\n};\n\n// Extract closed dates from first employee of each restaurant\nallEmployees.forEach(e => {\n  if (e.closed_dates && RESTAURANT_SHIFTS[e.restaurant_id]) {\n    RESTAURANT_SHIFTS[e.restaurant_id].closedDates = e.closed_dates.map(d => d.split('T')[0]);\n  }\n});\n\n// Track hours worked per employee this week\nconst hoursWorked = {};\nallEmployees.forEach(e => { hoursWorked[e.id] = 0; });\n\n// Track who worked which shift today to avoid double-booking\nconst dailyAssignments = {};\n\n// Helper: check if employee is on leave\nfunction isOnLeave(empId, date) {\n  const d = date.toISOString().split('T')[0];\n  return allLeaves.some(l => \n    l.employee_id === empId && \n    d >= l.start_date && d <= l.end_date\n  );\n}\n\n// Helper: check if it's employee's day off (0=Mon, 6=Sun) - supports multiple days\nfunction isDayOff(emp, date) {\n  if (!emp.days_off || emp.days_off.length === 0) return false;\n  const dayOfWeek = (date.getDay() + 6) % 7;\n  return emp.days_off.includes(dayOfWeek);\n}\n\n// Helper: check if restaurant is closed on date\nfunction isRestaurantClosed(restaurantId, dateStr) {\n  const closedDates = RESTAURANT_SHIFTS[restaurantId]?.closedDates || [];\n  return closedDates.includes(dateStr);\n}\n\n// Helper: check if part-time employee would exceed their hours\nfunction wouldExceedHours(emp, hoursToAdd) {\n  if (emp.employment_type !== 'part_time' || !emp.max_hours_per_week) return false;\n  return (hoursWorked[emp.id] + hoursToAdd) > emp.max_hours_per_week;\n}\n\n// Helper: check if employee already assigned today\nfunction alreadyAssignedToday(empId, dateStr) {\n  return dailyAssignments[dateStr]?.includes(empId);\n}\n\nconst shifts = [];\nconst planning = [];\nconst alerts = [];\nlet currentDate = new Date(startDate);\n\nwhile (currentDate <= endDate) {\n  const dateStr = currentDate.toISOString().split('T')[0];\n  dailyAssignments[dateStr] = [];\n  \n  [1, 2].forEach(restaurantId => {\n    const restoConfig = RESTAURANT_SHIFTS[restaurantId];\n    const restaurantName = restoConfig.name;\n    const dayShifts = [];\n    \n    // Skip if restaurant is closed\n    if (isRestaurantClosed(restaurantId, dateStr)) {\n      alerts.push(`${dateStr} ${restaurantName}: CLOSED`);\n      return;\n    }\n    \n    // Get available employees for this restaurant\n    const available = allEmployees.filter(e => {\n      if (e.restaurant_id !== restaurantId && !e.is_mobile) return false;\n      if (isOnLeave(e.id, currentDate)) return false;\n      if (isDayOff(e, currentDate)) return false;\n      if (e.employment_type === 'extra' && !includeExtras) return false;\n      return true;\n    });\n    \n    // Sort: full-time first, then part-time, then extras\n    // Secondary sort: employees with more days off work more shifts when available\n    available.sort((a, b) => {\n      const order = { full_time: 0, part_time: 1, extra: 2 };\n      const typeSort = (order[a.employment_type] || 0) - (order[b.employment_type] || 0);\n      if (typeSort !== 0) return typeSort;\n      const aDaysOff = a.days_off?.length || 0;\n      const bDaysOff = b.days_off?.length || 0;\n      return bDaysOff - aDaysOff;\n    });\n    \n    const dayIndex = Math.floor((currentDate - startDate) / (1000*60*60*24));\n    const shiftTypes = [restoConfig.morning, restoConfig.afternoon];\n    const shiftNames = ['morning', 'afternoon'];\n    \n    // Assign to each shift (morning and afternoon)\n    shiftTypes.forEach((shiftType, shiftIdx) => {\n      let shiftCount = 0;\n      const minPerShift = 3;\n      \n      // Rotate employees between morning/afternoon based on day\n      const rotatedEmployees = [...available];\n      if ((dayIndex + shiftIdx) % 2 === 1) {\n        rotatedEmployees.reverse();\n      }\n      \n      rotatedEmployees.forEach((emp, idx) => {\n        if (alreadyAssignedToday(emp.id, dateStr)) return;\n        if (shiftCount >= 5) return;\n        if (wouldExceedHours(emp, shiftType.hours)) return;\n        if (shiftCount >= minPerShift && (idx + dayIndex) % 2 !== shiftIdx) return;\n        \n        const positions = emp.positions || ['service'];\n        const position = positions[(dayIndex + idx) % positions.length];\n        const isMission = emp.restaurant_id !== restaurantId;\n        \n        const shift = {\n          employee_id: emp.id,\n          employee_name: `${emp.first_name} ${emp.last_name}`,\n          restaurant_id: restaurantId,\n          date: dateStr,\n          start_time: shiftType.start,\n          end_time: shiftType.end,\n          break_start: shiftType.break_start,\n          break_duration: 30,\n          position: position,\n          is_mission: isMission,\n          status: 'scheduled',\n          notes: `${shiftNames[shiftIdx]}${emp.employment_type !== 'full_time' ? ' (' + emp.employment_type.replace('_', '-') + ')' : ''}`\n        };\n        \n        shifts.push(shift);\n        dayShifts.push(shift);\n        hoursWorked[emp.id] += shiftType.hours;\n        dailyAssignments[dateStr].push(emp.id);\n        shiftCount++;\n      });\n      \n      if (shiftCount < minPerShift) {\n        alerts.push(`${dateStr} ${restaurantName} ${shiftNames[shiftIdx]}: Only ${shiftCount} employees (min ${minPerShift})`);\n      }\n    });\n    \n    planning.push({\n      date: dateStr,\n      restaurant: restaurantName,\n      shifts: dayShifts\n    });\n  });\n  \n  currentDate.setDate(currentDate.getDate() + 1);\n}\n\nconst suggestions = [\n  'Hua Hin: 11:00-23:00 (closed Jan 1st)',\n  'Sathorn: 10:30-00:30 (open every day)'\n];\nif (!includeExtras) suggestions.push('Extras not included - set include_extras=true to add them');\n\nreturn {\n  success: true,\n  create_shifts: createShifts,\n  period: {\n    start: startDate.toISOString().split('T')[0],\n    end: endDate.toISOString().split('T')[0]\n  },\n  planning: planning,\n  shifts: shifts,\n  total_shifts: shifts.length,\n  alerts: alerts,\n  suggestions: suggestions\n};"
      },
      "id": "generate-schedule",
      "name": "Generate Schedule",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [960, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {"caseSensitive": true, "leftValue": "", "typeValidation": "loose"},
          "conditions": [
            {
              "id": "check-create",
              "leftValue": "={{ $json.create_shifts }}",
              "rightValue": true,
              "operator": {"type": "boolean", "operation": "true"}
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-create",
      "name": "Create Shifts?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1200, 300]
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn data.shifts.map(s => ({ json: s }));"
      },
      "id": "prepare-shifts",
      "name": "Prepare Shifts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1440, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO shifts (employee_id, restaurant_id, date, start_time, end_time, break_start, break_duration, position, is_mission, status, notes) VALUES ({{ $json.employee_id }}, {{ $json.restaurant_id }}, '{{ $json.date }}', '{{ $json.start_time }}', '{{ $json.end_time }}', '{{ $json.break_start }}', {{ $json.break_duration }}, '{{ $json.position }}', {{ $json.is_mission }}, '{{ $json.status }}', '{{ $json.notes }}') RETURNING id;",
        "options": {}
      },
      "id": "insert-shifts",
      "name": "Insert Shifts",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1680, 200],
      "credentials": {"postgres": {"id": "GvtIl9xYacgDPoso", "name": "Planning PostgreSQL"}}
    },
    {
      "parameters": {
        "jsCode": "const data = $('Generate Schedule').first().json;\nconst inserted = $('Insert Shifts').all();\nreturn {\n  success: true,\n  message: `Created ${inserted.length} shifts`,\n  period: data.period,\n  shifts_created: inserted.length,\n  planning: data.planning\n};"
      },
      "id": "response-created",
      "name": "Response Created",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1920, 200]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "respond-created",
      "name": "Respond Created",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2160, 200]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "respond-preview",
      "name": "Respond Preview",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1440, 400]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [[{"node": "Fetch Employees", "type": "main", "index": 0}, {"node": "Fetch Leaves", "type": "main", "index": 0}]]
    },
    "Fetch Employees": {
      "main": [[{"node": "Merge", "type": "main", "index": 0}]]
    },
    "Fetch Leaves": {
      "main": [[{"node": "Merge", "type": "main", "index": 1}]]
    },
    "Merge": {
      "main": [[{"node": "Generate Schedule", "type": "main", "index": 0}]]
    },
    "Generate Schedule": {
      "main": [[{"node": "Create Shifts?", "type": "main", "index": 0}]]
    },
    "Create Shifts?": {
      "main": [
        [{"node": "Prepare Shifts", "type": "main", "index": 0}],
        [{"node": "Respond Preview", "type": "main", "index": 0}]
      ]
    },
    "Prepare Shifts": {
      "main": [[{"node": "Insert Shifts", "type": "main", "index": 0}]]
    },
    "Insert Shifts": {
      "main": [[{"node": "Response Created", "type": "main", "index": 0}]]
    },
    "Response Created": {
      "main": [[{"node": "Respond Created", "type": "main", "index": 0}]]
    }
  },
  "settings": {"executionOrder": "v1"},
  "triggerCount": 1,
  "active": true
}
